/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | foam-extend: Open Source CFD
   \\    /   O peration     | Version:     4.0
    \\  /    A nd           | Web:         http://www.foam-extend.org
     \\/     M anipulation  | For copyright notice see file Copyright
-------------------------------------------------------------------------------
License
    This file is part of foam-extend.

    foam-extend is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your
    option) any later version.

    foam-extend is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with foam-extend.  If not, see <http://www.gnu.org/licenses/>.

Description

\*---------------------------------------------------------------------------*/

#include "ULLSMaterialInterface.H"
#include "fvc.H"
#include "processorFvPatchFields.H"
#include "fvMatrices.H"
#include "skewCorrectionVectors.H"
#include "leastSquaresGrad.H"
#include "gaussGrad.H"
#include "faceSet.H"
#include "faMesh.H"
#include "faCFD.H"
#include "zeroGradientFaPatchFields.H"
#include "OStringStream.H"
#include "IStringStream.H"
#include "solidSolver.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

namespace Foam
{

// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //

defineTypeNameAndDebug(ULLSMaterialInterface, 0);

// * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * //


void ULLSMaterialInterface::makeDisplacementIncrement() const
{
    if (debug)
    {
        Info<< "void ULLSMaterialInterface::"
            << "makeInterfaceDisplacementIncrement() const : "
            << "creating interface displacement field"
            << endl;
    }

    // It is an error to attempt to recalculate
    // if the pointer is already set
    if (displacementIncrementPtr_)
    {
        FatalErrorIn("ULLSMaterialInterface::makeDisplacementIncrement() const")
            << "interface displacement increment field already exist"
            << abort(FatalError);
    }

    displacementIncrementPtr_ =
        new vectorField(faces().size(), vector::zero);

    // Initialize displacement increment
    surfaceVectorField DDf = fvc::interpolate(DD_);

    forAll(faces(), faceI)
    {
        label curFace = faces()[faceI];

        if (curFace < mesh().nInternalFaces())
        {
            (*displacementIncrementPtr_)[faceI] = DDf.internalField()[curFace];
        }
        else
        {
            label curPatch = mesh().boundaryMesh().whichPatch(curFace);
            label curPatchFace =
                curFace - mesh().boundaryMesh()[curPatch].start();

            (*displacementIncrementPtr_)[faceI] =
                DDf.boundaryField()[curPatch][curPatchFace];
        }
    }
}


void ULLSMaterialInterface::makeDisplacement() const
{
    if (debug)
    {
        Info<< "void ULLSMaterialInterface"
            << "::makeInterfaceDisplacement() const : "
            << "creating interface displacement field"
            << endl;
    }

    // It is an error to attempt to recalculate
    // if the pointer is already set
    if (displacementPtr_)
    {
        FatalErrorIn("ULLSMaterialInterface::makeDisplacement() const")
            << "interface displacement field already exist"
            << abort(FatalError);
    }

    displacementPtr_ = new vectorField(faces().size(), vector::zero);

    // Initialize displacement
    surfaceVectorField Df = fvc::interpolate(D_);

    forAll(faces(), faceI)
    {
        label curFace = faces()[faceI];

        if (curFace < mesh().nInternalFaces())
        {
            (*displacementPtr_)[faceI] = Df.internalField()[curFace];
        }
        else
        {
            label curPatch = mesh().boundaryMesh().whichPatch(curFace);
            label curPatchFace =
                curFace - mesh().boundaryMesh()[curPatch].start();

            (*displacementPtr_)[faceI] =
                Df.boundaryField()[curPatch][curPatchFace];
        }
    }
}


void ULLSMaterialInterface::makeTractionIncrement() const
{
    if (debug)
    {
        Info<< "void ULLSMaterialInterface::makeTractionIncrement() const : "
            << "creating interface traction increment field"
            << endl;
    }

    // It is an error to attempt to recalculate
    // if the pointer is already set
    if (tractionIncrementPtr_)
    {
        FatalErrorIn("ULLSMaterialInterface::makeTractionIncrement() const")
            << "interface traction increment field already exist"
            << abort(FatalError);
    }

    tractionIncrementPtr_ =
        new vectorField(faces().size(), vector::zero);
}


void ULLSMaterialInterface::makeTraction() const
{
    if (debug)
    {
        Info<< "void ULLSMaterialInterface::makeTraction() const : "
            << "creating interface traction field"
            << endl;
    }

    // It is an error to attempt to recalculate
    // if the pointer is already set
    if (tractionPtr_)
    {
        FatalErrorIn("ULLSMaterialInterface::makeTraction() const")
            << "interface traction field already exist"
            << abort(FatalError);
    }

    tractionPtr_ = new vectorField(faces().size(), vector::zero);
}


void ULLSMaterialInterface::makeDSigmaf() const
{
    if (debug)
    {
        Info<< "void ULLSMaterialInterface::makeDSigmaf() const : "
            << "creating interface second Piola-Kirchhoff stress incr field"
            << endl;
    }

    // It is an error to attempt to recalculate
    // if the pointer is already set
    if (ngbDSigmafPtr_ || ownDSigmafPtr_)
    {
        FatalErrorIn("ULLSMaterialInterface::makeDSigmaf() const")
            << "interface second Piola-Kirchhoff stress incr field "
                << "already exists"
                << abort(FatalError);
    }

    ownDSigmafPtr_ = new symmTensorField(faces().size(), symmTensor::zero);
    ngbDSigmafPtr_ = new symmTensorField(faces().size(), symmTensor::zero);
}


void ULLSMaterialInterface::makeSigmaf() const
{
    if (debug)
    {
        Info<< "void ULLSMaterialInterface::makeSigmaf() const : "
            << "creating interface old second Piola-Kirchhoff stress field"
            << endl;
    }

    // It is an error to attempt to recalculate
    // if the pointer is already set
    if (ngbSigmafPtr_ || ownSigmafPtr_)
    {
        FatalErrorIn("ULLSMaterialInterface::makeSigmaf() const")
            << "interface old second Piola-Kirchhoff stress field "
                << "already exists"
                << abort(FatalError);
    }

    ownSigmafPtr_ = new symmTensorField(faces().size(), symmTensor::zero);
    ngbSigmafPtr_ = new symmTensorField(faces().size(), symmTensor::zero);
}


void ULLSMaterialInterface::makeRelF() const
{
    if (debug)
    {
        Info<< "void ULLSMaterialInterface::makeRelF() const : "
            << "creating interface relative deformation gradient field"
            << endl;
    }

    // It is an error to attempt to recalculate
    // if the pointer is already set
    if (ngbRelFPtr_ || ownRelFPtr_)
    {
        FatalErrorIn("ULLSMaterialInterface::makeRelF() const")
            << "interface relative deformation gradient field "
                << "already exists"
                << abort(FatalError);
    }

    ownRelFPtr_ = new tensorField(faces().size(), I);
    ngbRelFPtr_ = new tensorField(faces().size(), I);
}


void ULLSMaterialInterface::makeF() const
{
    if (debug)
    {
        Info<< "void ULLSMaterialInterface::makeF() const : "
            << "creating interface deformation gradient field"
            << endl;
    }

    // It is an error to attempt to recalculate
    // if the pointer is already set
    if (ngbFPtr_ || ownFPtr_)
    {
        FatalErrorIn("ULLSMaterialInterface::makeF() const")
            << "interface old deformation gradient field "
                << "already exists"
                << abort(FatalError);
    }

    ownFPtr_ = new tensorField(faces().size(), I);
    ngbFPtr_ = new tensorField(faces().size(), I);
}


void ULLSMaterialInterface::makeBbar() const
{
    if (debug)
    {
        Info<< "void ULLSMaterialInterface::makeF() const : "
            << "creating interface deformation gradient field"
            << endl;
    }

    // It is an error to attempt to recalculate
    // if the pointer is already set
    if (ngbBbarPtr_ || ownBbarPtr_)
    {
        FatalErrorIn("ULLSMaterialInterface::makeF() const")
            << "interface old deformation gradient field "
                << "already exists"
                << abort(FatalError);
    }

    ownBbarPtr_ = new symmTensorField(faces().size(), I);
    ngbBbarPtr_ = new symmTensorField(faces().size(), I);
}


void ULLSMaterialInterface::makeSubMeshPointDD() const
{
    if (debug)
    {
        Info<< "void ULLSMaterialInterface::makeSubMeshPointDD() const : "
            << "creating point displacements increment fields"
            << endl;
    }

    // It is an error to attempt to recalculate
    // if the pointer is already set
    if (!subMeshPointDD_.empty())
    {
        FatalErrorIn("ULLSMaterialInterface::makeSubMeshPointDD() const")
            << "Point displacement increment fields already exist"
            << abort(FatalError);
    }

    subMeshPointDD_.setSize(subMeshes().size());

    forAll(subMeshPointDD_, meshI)
    {
        subMeshPointDD_.set
        (
            meshI,
            new pointVectorField
            (
                subMeshes()[meshI].interpolate(pointDD_)
            )
        );
    }
}


void ULLSMaterialInterface::makeSubMeshDD() const
{
    if (debug)
    {
        Info<< "void ULLSMaterialInterface::makeSubMeshDD() const : "
            << "creating displacements fields"
            << endl;
    }

    // It is an error to attempt to recalculate
    // if the pointer is already set
    if (!subMeshDD_.empty())
    {
        FatalErrorIn("ULLSMaterialInterface::makeSubMeshDD() const")
            << "Displacement increment fields already exist"
            << abort(FatalError);
    }

    subMeshDD_.setSize(subMeshes().size());

    forAll(subMeshDD_, meshI)
    {
        OStringStream SubsetName;
        SubsetName() << Pstream::myProcNo() << '_' << meshI << '_'
            << DD_.name();

        subMeshDD_.set
        (
            meshI,
            new volVectorField
            (
                IOobject
                (
                    word(SubsetName.str()),
                    subMeshes()[meshI].subMesh().time().timeName(),
                    subMeshes()[meshI].subMesh(),
                    IOobject::NO_READ,
                    IOobject::NO_WRITE
                ),
                subMeshes()[meshI].subMesh(),
                dimensionedVector("0", DD_.dimensions(), vector::zero)
            )
        );

        subMeshDD_[meshI] = subMeshes()[meshI].interpolate(DD_);

        // Correct displacement field at the interface
        const labelList& patchMap = subMeshes()[meshI].patchMap();
        label interfacePatchIndex = -1;
        forAll(patchMap, patchI)
        {
            if (patchMap[patchI] == -1)
            {
                interfacePatchIndex = patchI;
                break;
            }
        }

        if (interfacePatchIndex != -1)
        {
            vectorField& interfaceDD =
                subMeshDD_[meshI].boundaryField()[interfacePatchIndex];

            const labelList& fm = subMeshes()[meshI].faceMap();

            label interfacePatchStart =
                subMeshes()[meshI].subMesh().boundaryMesh()
                [
                    interfacePatchIndex
                ].start();

            forAll(interfaceDD, faceI)
            {
                label curInterFace =
                    findIndex(faces(), fm[interfacePatchStart + faceI]);

                interfaceDD[faceI] =
                    displacementIncrement()[curInterFace];
            }
        }
    }
}


void ULLSMaterialInterface::clearOut()
{
    deleteDemandDrivenData(displacementIncrementPtr_);
    deleteDemandDrivenData(displacementPtr_);
    deleteDemandDrivenData(tractionIncrementPtr_);
    deleteDemandDrivenData(tractionPtr_);

    deleteDemandDrivenData(ownDSigmafPtr_);
    deleteDemandDrivenData(ngbDSigmafPtr_);

    deleteDemandDrivenData(ownSigmafPtr_);
    deleteDemandDrivenData(ngbSigmafPtr_);
}


// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //


ULLSMaterialInterface::ULLSMaterialInterface
(
    const volVectorField& DD,
    const pointVectorField& pointDD,
    const volVectorField& D
)
:
    materialInterface(DD.mesh()),
    DD_(DD),
    pointDD_(pointDD),
    D_(D),
    curTimeIndex_(-1),
    displacementIncrementPtr_(NULL),
    displacementPtr_(NULL),
    tractionIncrementPtr_(NULL),
    tractionPtr_(NULL),
    ownDSigmafPtr_(NULL),
    ngbDSigmafPtr_(NULL),
    ownSigmafPtr_(NULL),
    ngbSigmafPtr_(NULL),
    ownRelFPtr_(NULL),
    ngbRelFPtr_(NULL),
    ownFPtr_(NULL),
    ngbFPtr_(NULL),
    ownBbarPtr_(NULL),
    ngbBbarPtr_(NULL)
{}


// * * * * * * * * * * * * * * * Destructor * * * * * * * * * * * * * * * * * //

ULLSMaterialInterface::~ULLSMaterialInterface()
{
    clearOut();
}

// * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * * //

vectorField& ULLSMaterialInterface::displacementIncrement()
{
    if (!displacementIncrementPtr_)
    {
        makeDisplacementIncrement();
    }

    return *displacementIncrementPtr_;
}

const vectorField& ULLSMaterialInterface::displacementIncrement() const
{
    if (!displacementIncrementPtr_)
    {
        makeDisplacementIncrement();
    }

    return *displacementIncrementPtr_;
}

vectorField& ULLSMaterialInterface::displacement()
{
    if (!displacementPtr_)
    {
        makeDisplacement();
    }

    return *displacementPtr_;
}

const vectorField& ULLSMaterialInterface::displacement() const
{
    if (!displacementPtr_)
    {
        makeDisplacement();
    }

    return *displacementPtr_;
}

vectorField& ULLSMaterialInterface::tractionIncrement()
{
    if (!tractionIncrementPtr_)
    {
        makeTractionIncrement();
    }

    return *tractionIncrementPtr_;
}

const vectorField& ULLSMaterialInterface::tractionIncrement() const
{
    if (!tractionIncrementPtr_)
    {
        makeTractionIncrement();
    }

    return *tractionIncrementPtr_;
}

vectorField& ULLSMaterialInterface::traction()
{
    if (!tractionPtr_)
    {
        makeTraction();
    }

    return *tractionPtr_;
}

const vectorField& ULLSMaterialInterface::traction() const
{
    if (!tractionPtr_)
    {
        makeTraction();
    }

    return *tractionPtr_;
}

symmTensorField& ULLSMaterialInterface::ownSigmaf()
{
    if (!ownSigmafPtr_)
    {
        makeSigmaf();
    }

    return *ownSigmafPtr_;
}

const symmTensorField& ULLSMaterialInterface::ownSigmaf() const
{
    if (!ownSigmafPtr_)
    {
        makeSigmaf();
    }

    return *ownSigmafPtr_;
}

symmTensorField& ULLSMaterialInterface::ngbSigmaf()
{
    if (!ngbSigmafPtr_)
    {
        makeSigmaf();
    }

    return *ngbSigmafPtr_;
}

const symmTensorField& ULLSMaterialInterface::ngbSigmaf() const
{
    if (!ngbSigmafPtr_)
    {
        makeSigmaf();
    }

    return *ngbSigmafPtr_;
}

symmTensorField& ULLSMaterialInterface::ownDSigmaf()
{
    if (!ownDSigmafPtr_)
    {
        makeDSigmaf();
    }

    return *ownDSigmafPtr_;
}

const symmTensorField& ULLSMaterialInterface::ownDSigmaf() const
{
    if (!ownDSigmafPtr_)
    {
        makeDSigmaf();
    }

    return *ownDSigmafPtr_;
}

symmTensorField& ULLSMaterialInterface::ngbDSigmaf()
{
    if (!ngbDSigmafPtr_)
    {
        makeDSigmaf();
    }

    return *ngbDSigmafPtr_;
}

const symmTensorField& ULLSMaterialInterface::ngbDSigmaf() const
{
    if (!ngbDSigmafPtr_)
    {
        makeDSigmaf();
    }

    return *ngbDSigmafPtr_;
}

tensorField& ULLSMaterialInterface::ownRelF()
{
    if (!ownRelFPtr_)
    {
        makeRelF();
    }

    return *ownRelFPtr_;
}

tensorField& ULLSMaterialInterface::ngbRelF()
{
    if (!ngbRelFPtr_)
    {
        makeRelF();
    }

    return *ngbRelFPtr_;
}

const tensorField& ULLSMaterialInterface::ownRelF() const
{
    if (!ownRelFPtr_)
    {
        makeRelF();
    }

    return *ownRelFPtr_;
}

const tensorField& ULLSMaterialInterface::ngbRelF() const
{
    if (!ngbRelFPtr_)
    {
        makeRelF();
    }

    return *ngbRelFPtr_;
}

tensorField& ULLSMaterialInterface::ownF()
{
    if (!ownFPtr_)
    {
        makeF();
    }

    return *ownFPtr_;
}

tensorField& ULLSMaterialInterface::ngbF()
{
    if (!ngbFPtr_)
    {
        makeF();
    }

    return *ngbFPtr_;
}

const tensorField& ULLSMaterialInterface::ownF() const
{
    if (!ownFPtr_)
    {
        makeF();
    }

    return *ownFPtr_;
}

const tensorField& ULLSMaterialInterface::ngbF() const
{
    if (!ngbFPtr_)
    {
        makeF();
    }

    return *ngbFPtr_;
}

symmTensorField& ULLSMaterialInterface::ownBbar()
{
    if (!ownBbarPtr_)
    {
        makeBbar();
    }

    return *ownBbarPtr_;
}

symmTensorField& ULLSMaterialInterface::ngbBbar()
{
    if (!ngbBbarPtr_)
    {
        makeBbar();
    }

    return *ngbBbarPtr_;
}

const symmTensorField& ULLSMaterialInterface::ownBbar() const
{
    if (!ownBbarPtr_)
    {
        makeBbar();
    }

    return *ownBbarPtr_;
}

const symmTensorField& ULLSMaterialInterface::ngbBbar() const
{
    if (!ngbBbarPtr_)
    {
        makeBbar();
    }

    return *ngbBbarPtr_;
}


const PtrList<volVectorField>& ULLSMaterialInterface::subMeshDD() const
{
    if (subMeshDD_.empty())
    {
        makeSubMeshDD();
    }

    return subMeshDD_;
}

PtrList<volVectorField>& ULLSMaterialInterface::subMeshDD()
{
    if (subMeshDD_.empty())
    {
        makeSubMeshDD();
    }

    return subMeshDD_;
}

const PtrList<pointVectorField>& ULLSMaterialInterface::subMeshPointDD() const
{
    if (subMeshPointDD_.empty())
    {
        makeSubMeshPointDD();
    }

    return subMeshPointDD_;
}

PtrList<pointVectorField>& ULLSMaterialInterface::subMeshPointDD()
{
    if (subMeshPointDD_.empty())
    {
        makeSubMeshPointDD();
    }

    return subMeshPointDD_;
}

void ULLSMaterialInterface::correct(fvVectorMatrix& DEqn)
{}


void ULLSMaterialInterface::correct(surfaceVectorField& trac) const
{
    forAll(faces(), faceI)
    {
        label curFace = faces()[faceI];

        if (curFace < mesh().nInternalFaces())
        {
            trac.internalField()[curFace] = traction()[faceI];
        }
        else
        {
            label curPatch = mesh().boundaryMesh().whichPatch(curFace);
            label curPatchFace =
                curFace - mesh().boundaryMesh()[curPatch].start();

            trac.boundaryField()[curPatch][curPatchFace] = traction()[faceI];
        }
    }
}


tmp<vectorField> ULLSMaterialInterface::cauchyTraction
(
    const vector& m,
    const label faceI,
    const volTensorField& gradDD,
    const surfaceTensorField& gradDDf,
    const volScalarField& mu,
    const volScalarField& lambda
) const
{
    tmp<vectorField> tCauchyTraction(new vectorField(2, vector::zero));

    const unallocLabelList& owner = mesh().owner();
    const unallocLabelList& neighbour = mesh().neighbour();

    const vectorField& C  = mesh().C().internalField();
    const vectorField& Cf  = mesh().Cf().internalField();
    const vectorField& SI = mesh().Sf().internalField();
    const scalarField& magSI  = mesh().magSf().internalField();
    const scalarField& deltaCoeffs = mesh().deltaCoeffs().internalField();
    const scalarField& w = mesh().weights().internalField();

    const vectorField& DDI = DD_.internalField();

    const tensorField& gradDDI = gradDD.internalField();
    const tensorField& gradDDfI = gradDDf.internalField();

    label curFace = faces()[faceI];

    label curOwner = owner[curFace];
    label curNeighbour = neighbour[curFace];

    vector ownN = SI[curFace]/magSI[curFace];
    vector ngbN = -ownN;

    vector ownCorrVec = Cf[curFace] - C[curOwner];
    ownCorrVec -= ownN*(ownN & ownCorrVec);
    vector ngbCorrVec = Cf[curFace] - C[curNeighbour];
    ngbCorrVec -= ngbN*(ngbN&ngbCorrVec);

    vector ownDD = DDI[curOwner];
    ownDD += (ownCorrVec & gradDDI[curOwner]);
    vector ngbDD = DDI[curNeighbour];
    ngbDD += (ngbCorrVec & gradDDI[curNeighbour]);

    scalar ngbDeltaN = w[curFace]*(1.0/deltaCoeffs[curFace]);
    scalar ownDeltaN = (1.0/deltaCoeffs[curFace]) - ngbDeltaN;

    vector interDD = m;
//     vector interDD = vector::zero;
//     for (direction cmpt = 0; cmpt < vector::nComponents; cmpt++)
//     {
//         interDD.replace
//         (
//             cmpt,
//             ownDD.component(cmpt)
//           + m.component(cmpt)*(ngbDD.component(cmpt) - ownDD.component(cmpt))
//         );
//     }

    tensor ownGradDD = gradDDfI[curFace];
    ownGradDD +=
        ownN*(interDD - ownDD)/ownDeltaN
      - ownN*(ownN & ownGradDD);

    tensor ngbGradDD = gradDDfI[curFace];
    ngbGradDD +=
        ngbN*(interDD - ngbDD)/ngbDeltaN
      - ngbN*(ngbN & ngbGradDD);

    tensor ownRelFcur = I + ownGradDD.T();
    tensor ngbRelFcur = I + ngbGradDD.T();

    scalar ownRelJ = det(ownRelFcur);
    scalar ngbRelJ = det(ngbRelFcur);

    tensor ownInvRelF = hinv(ownRelFcur);
    tensor ngbInvRelF = hinv(ngbRelFcur);

    vector ownS = (ownInvRelF.T() & SI[curFace])*ownRelJ;
    vector ngbS = (ngbInvRelF.T() & SI[curFace])*ngbRelJ;
    vector S = 0.5*(ownS + ngbS);
    vector N = S/(mag(S) + SMALL);

    tensor ownRelFbar = pow(ownRelJ, -1.0/3.0)*ownRelFcur;
    tensor ngbRelFbar = pow(ngbRelJ, -1.0/3.0)*ngbRelFcur;

    tensor ownFcur = (ownRelFcur & ownF()[faceI]);
    tensor ngbFcur = (ngbRelFcur & ngbF()[faceI]);

    scalar ownJ = det(ownFcur);
    scalar ngbJ = det(ngbFcur);

    symmTensor ownBbarCur =
        symm(ownRelFbar & ownBbar()[faceI] & ownRelFbar.T());
    symmTensor ngbBbarCur =
        symm(ngbRelFbar & ngbBbar()[faceI] & ngbRelFbar.T());

    scalar ownMu = mu.internalField()[curOwner];
    scalar ngbMu = mu.internalField()[curNeighbour];

    scalar ownLambda = lambda.internalField()[curOwner];
    scalar ngbLambda = lambda.internalField()[curNeighbour];

    scalar ownK  = (ownLambda + (2.0/3.0)*ownMu);
    scalar ngbK  = (ngbLambda + (2.0/3.0)*ngbMu);

    symmTensor ownTau =
        ownMu*dev(ownBbarCur)
      + 0.5*ownK*(sqr(ownJ) - 1.0)*I;
    symmTensor ngbTau =
        ngbMu*dev(ngbBbarCur)
      + 0.5*ngbK*(sqr(ngbJ) - 1.0)*I;

    tCauchyTraction()[0] = (S & ownTau)/ownJ;
    tCauchyTraction()[1] = (S & ngbTau)/ngbJ;

    return tCauchyTraction;
}


void ULLSMaterialInterface::updateInterfaceDisplacementIncrement()
{
    if (curTimeIndex_ != mesh().time().timeIndex())
    {
        // Update total fields
        scalarField ownRelJ = det(ownRelF());
        scalarField ngbRelJ = det(ngbRelF());

        ownF() = (ownRelF() & ownF());
        ngbF() = (ngbRelF() & ngbF());

        tensorField ownRelFbar = pow(ownRelJ, -1.0/3.0)*ownRelF();
        tensorField ngbRelFbar = pow(ngbRelJ, -1.0/3.0)*ngbRelF();

        ownBbar() = symm(ownRelFbar & ownBbar() & ownRelFbar);
        ngbBbar() = symm(ngbRelFbar & ngbBbar() & ngbRelFbar);

        curTimeIndex_ = mesh().time().timeIndex();
    }

    const unallocLabelList& owner = mesh().owner();
    const unallocLabelList& neighbour = mesh().neighbour();

    const vectorField& DDI = DD_.internalField();

    const volTensorField& gradDD =
        mesh().lookupObject<volTensorField>("grad(" + DD_.name() + ')');
    const tensorField& gradDDI = gradDD.internalField();

    const surfaceTensorField& gradDDf =
        mesh().lookupObject<surfaceTensorField>("grad" + DD_.name() + 'f');
//     const tensorField& gradDDfI = gradDDf.internalField();

    const volScalarField& mu =
        mesh().lookupObject<volScalarField>("mu");
    const volScalarField& lambda =
        mesh().lookupObject<volScalarField>("lambda");

    const vectorField& C  = mesh().C().internalField();
    const vectorField& Cf  = mesh().Cf().internalField();

    const vectorField& SI = mesh().Sf().internalField();
    const scalarField& magSI  = mesh().magSf().internalField();
    const scalarField& deltaCoeffs = mesh().deltaCoeffs().internalField();
    const scalarField& w = mesh().weights().internalField();

    vectorField& interDD = displacementIncrement();

    // Interface faces
    forAll(faces(), faceI)
    {
        label curFace = faces()[faceI];

        // Internal faces
        if (curFace < mesh().nInternalFaces())
        {
            // Calculate initial interface displacement increment
            // using extrapolation

            label curOwner = owner[curFace];
            label curNeighbour = neighbour[curFace];

            vector ownDD = DDI[curOwner];
            vector ngbDD = DDI[curNeighbour];

            vector ownDelta = Cf[curFace] - C[curOwner];
            vector ngbDelta = Cf[curFace] - C[curNeighbour];

            interDD[faceI] =
            (
                ownDD + (ownDelta & gradDDI[curOwner])
              + ngbDD + (ngbDelta & gradDDI[curNeighbour])
            )/2;

            // Check equilibrium
            vector ownN = SI[curFace]/magSI[curFace];
            vector ngbN = -ownN;

            vector ownCorrVec = Cf[curFace] - C[curOwner];
            ownCorrVec -= ownN*(ownN&ownCorrVec);
            vector ngbCorrVec = Cf[curFace] - C[curNeighbour];
            ngbCorrVec -= ngbN*(ngbN&ngbCorrVec);

            ownDD += (ownCorrVec & gradDDI[curOwner]);
            ngbDD += (ngbCorrVec & gradDDI[curNeighbour]);

//             vector m = vector::zero;

//             for (direction cmpt = 0; cmpt < vector::nComponents; cmpt++)
//             {
//                 m.replace
//                 (
//                     cmpt,
//                     (
//                         interDD[faceI].component(cmpt)
//                       - ownDD.component(cmpt)
//                     )
//                    /(
//                         ngbDD.component(cmpt)
//                       - ownDD.component(cmpt)
//                       + SMALL
//                     )
//                 );
//             }

            vectorField curCauchyTraction =
                cauchyTraction(interDD[faceI], faceI, gradDD, gradDDf, mu, lambda);

            vector ownTraction = curCauchyTraction[0];
            vector ngbTraction = curCauchyTraction[1];

            Info << "traction: " << ownTraction << ", " << ngbTraction << endl;

            scalar ownMu = mu.internalField()[curOwner];
            scalar ownLambda = lambda.internalField()[curOwner];

            scalar ngbDeltaN = w[curFace]*(1.0/deltaCoeffs[curFace]);
            scalar ownDeltaN = (1.0/deltaCoeffs[curFace]) - ngbDeltaN;

            vector newInterDD = interDD[faceI];

            scalar residual = GREAT;
            label iCorr = 0;
            label MaxIter = 100;
            do
            {
                vector ownNGradDD = (newInterDD - ownDD)/ownDeltaN;

                ownNGradDD =
                    (ngbTraction - ownTraction)
                   /((2*ownMu + ownLambda)*magSI[curFace])
                  + ownNGradDD;

                newInterDD = ownDD + ownDeltaN*ownNGradDD;

                vectorField newCauchyTraction =
                    cauchyTraction(newInterDD, faceI, gradDD, gradDDf, mu, lambda);

                vector oldOwnTraction = ownTraction;
                ownTraction = newCauchyTraction[0];
                ngbTraction = newCauchyTraction[1];

                residual = mag(ownTraction - oldOwnTraction);

                if (iCorr == MaxIter)
                {
                    Warning << "Iterative method does not converge "
                        << residual << endl;
                }
            }
            while( residual > 1e-4 && ++iCorr < MaxIter);

            Info << "traction: " << ownTraction << ", "
                << ngbTraction << ", " << iCorr << ", " << residual  << endl;
        }

            // Inforce equilibrium of traction across the interface

//             vector ownN = SI[curFace]/magSI[curFace];
//             vector ngbN = -ownN;

//             vector ownCorrVec = Cf[curFace] - C[curOwner];
//             ownCorrVec -= ownN*(ownN&ownCorrVec);
//             vector ngbCorrVec = Cf[curFace] - C[curNeighbour];
//             ngbCorrVec -= ngbN*(ngbN&ngbCorrVec);

//             ownDD += (ownCorrVec & gradDDI[curOwner]);
//             ngbDD += (ngbCorrVec & gradDDI[curNeighbour]);


//             vector m0(-0.5, -0.5, -0.5);
//             vector m1(1.5, 1.5, 1.5);

//             vectorField cauchyTraction0 =
//                 cauchyTraction(m0, faceI, gradDD, gradDDf, mu, lambda);
//             vectorField cauchyTraction1 =
//                 cauchyTraction(m1, faceI, gradDD, gradDDf, mu, lambda);

//             vector f0 = cauchyTraction0[1] - cauchyTraction0[0];
//             vector f1 = cauchyTraction1[1] - cauchyTraction1[0];

//             bool outOfRange = false;
//             for (direction cmpt = 0; cmpt < vector::nComponents; cmpt++)
//             {
//                 if (f0.component(cmpt)*f1.component(cmpt) > SMALL)
//                 {
//                     Info << "out of range " << faceI << endl;
//                     outOfRange = true;
//                 }

//                 m0.replace
//                 (
//                     cmpt,
//                     (
//                         interDD[faceI].component(cmpt)
//                       - ownDD.component(cmpt)
//                     )
//                    /(
//                         ngbDD.component(cmpt)
//                       - ownDD.component(cmpt)
//                       + SMALL
//                     )
//                 );

//                 if (m0.component(cmpt) < 0)
//                 {
//                     Info << "m0.component(cmpt) < 0; "
//                         << m0.component(cmpt) << endl;
//                     outOfRange = true;
//                 }

//                 if (m0.component(cmpt) > 1)
//                 {
//                     Info << "m0.component(cmpt) > 1 "
//                         << m0.component(cmpt) << endl;
//                     outOfRange = true;
//                 }



//                 if (m0.component(cmpt) >= 0.5)
//                 {
//                     m1.component(cmpt) = 0.9*m0.component(cmpt);
//                 }
//                 else
//                 {
//                     m1.component(cmpt) = 1.1*m0.component(cmpt);
//                 }
//             }

//             if (!outOfRange)
//             {
//                 //Bisection method
//                 vector residual(GREAT, GREAT, GREAT);
//                 label iCorr = 0;
//                 label MaxIter = 100;
//                 vector mMid = vector::zero;
//                 do
//                 {
//                     mMid = 0.5*(m0 + m1);

//                     vectorField cauchyTractionMid =
//                         cauchyTraction
//                         (
//                             mMid, faceI, gradDD, gradDDf, mu, lambda
//                         );

//                     vector fMid = cauchyTractionMid[1] - cauchyTractionMid[0];

//                     for
//                     (
//                         direction cmpt = 0;
//                         cmpt < vector::nComponents;
//                         cmpt++
//                     )
//                     {
//                         if (f0.component(cmpt)*fMid.component(cmpt)<0)
//                         {
//                             m1.component(cmpt) = mMid.component(cmpt);
//                             f1.component(cmpt) = fMid.component(cmpt);

// //                             residual.component(cmpt) =
// //                                 mag
// //                                 (
// //                                     m1.component(cmpt)
// //                                   - m0.component(cmpt)
// //                                 );
//                         }
//                         else
//                         {
//                             m0.component(cmpt) = mMid.component(cmpt);
//                             f0.component(cmpt) = fMid.component(cmpt);

// //                             residual.component(cmpt) =
// //                                 mag
// //                                 (
// //                                     m1.component(cmpt)
// //                                   - m0.component(cmpt)
// //                                 );
//                         }
//                     }

//                     if (iCorr == MaxIter)
//                     {
//                         Warning << "Bisection method does not converge "
//                             << fMid << ", " << residual << endl;
//                     }
//                 }
//                 while( mag(residual) > 1e-4 && ++iCorr < MaxIter);

//                 vectorField curCauchyTraction =
//                     cauchyTraction(mMid, faceI, gradDD, gradDDf, mu, lambda);

//                 vector ownTraction = curCauchyTraction[0];
//                 vector ngbTraction = curCauchyTraction[1];

//                 Info << "traction: " << ownTraction << ", "
//                     << ngbTraction << ", "
//                     << iCorr << ", " << residual << ", " << mMid << endl;
//             }

//             if (false)
//             {
//             // Secont method
//             vectorField cauchyTraction0 =
//                 cauchyTraction(m0, faceI, gradDD, gradDDf, mu, lambda);

//             vectorField cauchyTraction1 =
//                 cauchyTraction(m1, faceI, gradDD, gradDDf, mu, lambda);

//             vector f0 = cauchyTraction0[1] - cauchyTraction0[0];
//             vector f1 = cauchyTraction1[1] - cauchyTraction1[0];

//             vector residual(GREAT, GREAT, GREAT);
//             label iCorr = 0;
//             label MaxIter = 100;
//             vector m2 = vector::zero;

//             do
//             {
//                 for (direction cmpt = 0; cmpt < vector::nComponents; cmpt++)
//                 {
//                     m2.component(cmpt) =
//                         m1.component(cmpt)
//                       - f1.component(cmpt)
//                        *(m1.component(cmpt) - m0.component(cmpt))
//                        /(f1.component(cmpt) - f0.component(cmpt) + SMALL);

//                     residual.component(cmpt) =
//                         mag(m2.component(cmpt) - m1.component(cmpt));
//                 }

//                 vectorField cauchyTraction2 =
//                     cauchyTraction(m2, faceI, gradDD, gradDDf, mu, lambda);

//                 vector f2 = cauchyTraction2[1] - cauchyTraction2[0];

//                 m0 = m1;
//                 m1 = m2;
//                 f0 = f1;
//                 f1 = f2;

//                 if (iCorr == MaxIter)
//                 {
//                     Warning << "Secant method does not converge "
//                         << f2 << ", " << residual << endl;
//                 }
//             }
//             while( mag(residual) > 1e-4 && ++iCorr < MaxIter);

// //             vectorField curCauchyTraction =
// //                 cauchyTraction(m2, faceI, gradDD, gradDDf, mu, lambda);

// //             vector ownTraction = curCauchyTraction[0];
// //             vector ngbTraction = curCauchyTraction[1];

// //             Info << "traction: " << ownTraction << ", "
// //                 << ngbTraction << endl;

//             for (direction cmpt = 0; cmpt < vector::nComponents; cmpt++)
//             {
//                 interDD[faceI].replace
//                 (
//                     cmpt,
//                     ownDD.component(cmpt)
//                   + m2.component(cmpt)
//                   *(ngbDD.component(cmpt) - ownDD.component(cmpt))
//                 );
//             }

//             Info << faceI << ", " << m2 << ", "
//                 << f1 << ", " << iCorr << ", " << residual << endl;
//             }
//         }




    }
}


void ULLSMaterialInterface::correctInterfaceGradient
(
    surfaceTensorField& gradDDf
)
{
    const unallocLabelList& owner = mesh().owner();
    const unallocLabelList& neighbour = mesh().neighbour();

    const vectorField& DDI = DD_.internalField();

    const volTensorField& gradDD =
        mesh().lookupObject<volTensorField>("grad(" + DD_.name() + ')');
    const tensorField& gradDDI = gradDD.internalField();

    const volScalarField& mu =
        mesh().lookupObject<volScalarField>("mu");
    const volScalarField& lambda =
        mesh().lookupObject<volScalarField>("lambda");

    const vectorField& SI  = mesh().Sf().internalField();
    const scalarField& magSI  = mesh().magSf().internalField();
    const scalarField& deltaCoeffs = mesh().deltaCoeffs().internalField();
    const scalarField& w = mesh().weights().internalField();

    const vectorField& C  = mesh().C().internalField();
    const vectorField& Cf  = mesh().Cf().internalField();

    const vectorField& interDD = displacementIncrement();

    tensorField& gradDDfI = gradDDf.internalField();

    // Interface faces
    forAll(faces(), faceI)
    {
        label curFace = faces()[faceI];

        // Internal faces
        if (curFace < mesh().nInternalFaces())
        {
            label curOwner = owner[curFace];
            label curNeighbour = neighbour[curFace];

            vector ownN = SI[curFace]/magSI[curFace];
            vector ngbN = -ownN;

            scalar ngbDeltaN = w[curFace]*(1.0/deltaCoeffs[curFace]);
            scalar ownDeltaN = (1.0/deltaCoeffs[curFace]) - ngbDeltaN;

            scalar ownMu = mu.internalField()[curOwner];
            scalar ngbMu = mu.internalField()[curNeighbour];

            scalar ownLambda = lambda.internalField()[curOwner];
            scalar ngbLambda = lambda.internalField()[curNeighbour];

            scalar ownK  = (ownLambda + (2.0/3.0)*ownMu);
            scalar ngbK  = (ngbLambda + (2.0/3.0)*ngbMu);

            vector ownDD = DDI[curOwner];
            vector ngbDD = DDI[curNeighbour];

            vector ownCorrVec = Cf[curFace] - C[curOwner];
            ownCorrVec -= ownN*(ownN & ownCorrVec);

            vector ngbCorrVec = Cf[curFace] - C[curNeighbour];
            ngbCorrVec -= ngbN*(ngbN&ngbCorrVec);

            vector ownDDCorr = (ownCorrVec & gradDDI[curOwner]);
            vector ngbDDCorr = (ngbCorrVec&gradDDI[curNeighbour]);

            if (ngbK > ownK)
            {
                gradDDfI[curFace] -= ngbN*(ngbN & gradDDfI[curFace]);
                gradDDfI[curFace] +=
                    ngbN*(interDD[faceI] - (ngbDD + ngbDDCorr))/ngbDeltaN;
            }
            else
            {
                gradDDfI[curFace] -= ownN*(ownN & gradDDfI[curFace]);
                gradDDfI[curFace] +=
                    ownN*(interDD[faceI] - (ownDD + ownDDCorr))/ownDeltaN;
            }
        }
    }
}


void ULLSMaterialInterface::updateDisplacementIncrement
(
    pointVectorField& pointDD
)
{
    if (debug)
    {
        Info<< "ULLSMaterialInterface::updateDisplacementIncrement("
            << "pointVectorField&)"
            << "interpolating displacement incr field from cells to points"
            << endl;
    }

    updateInterfaceDisplacementIncrement();

    materialInterface::updateDisplacement
    (
        DD_,
        displacementIncrement(),
        pointDD,
        subMeshDD(),
        subMeshPointDD()
    );
}


void ULLSMaterialInterface::updateDisplacementIncrementGradient
(
    volTensorField& gradDD,
    surfaceTensorField& gradDDf
)
{
    materialInterface::updateDisplacementGradient
    (
        DD_,
        subMeshDD(),
        subMeshPointDD(),
        gradDD,
        gradDDf
    );

    correctInterfaceGradient(gradDDf);
}


void ULLSMaterialInterface::modifyProperty
(
    surfaceScalarField& muf,
    const volScalarField& mu
) const
{
    const unallocLabelList& owner = mesh().owner();
    const unallocLabelList& neighbour = mesh().neighbour();

    const volScalarField& Mu =
        mesh().lookupObject<volScalarField>("mu");
    const volScalarField& Lambda =
        mesh().lookupObject<volScalarField>("lambda");

    forAll(faces(), faceI)
    {
        label curFace = faces()[faceI];

        if (curFace < mesh().nInternalFaces())
        {
            scalar ownK =
                Lambda[owner[curFace]]
              + (2.0/3.0)*Mu[owner[curFace]];
            scalar ngbK =
                Lambda[neighbour[curFace]]
              + (2.0/3.0)*Mu[neighbour[curFace]];

//             Info << "mu " << Mu[owner[curFace]]
//                 << ", " << Mu[neighbour[curFace]] << endl;

//             Info << "lambda " << Lambda[owner[curFace]]
//                 << ", " << Lambda[neighbour[curFace]] << endl;

//             Info << "K " << ownK << ", " << ngbK << endl;

            if (ngbK > ownK)
            {
                muf.internalField()[curFace] = mu[neighbour[curFace]];
            }
            else
            {
                muf.internalField()[curFace] = mu[owner[curFace]];
            }
        }
        else
        {
            // To do ???
            label curPatch = mesh().boundaryMesh().whichPatch(curFace);
            label curPatchFace =
                curFace - mesh().boundaryMesh()[curPatch].start();

            muf.boundaryField()[curPatch][curPatchFace] = 0;
        }
    }
}


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

} // End namespace Foam

// ************************************************************************* //
